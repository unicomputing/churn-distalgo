import random
import time
import configparser 
import json
import sys

ALPHA=0.05
BETA = 0.6
GAMMA = 0.6
NUM_INIT_NODE = 20

# ----------------------------------------
# Node class
# ----------------------------------------

class Node (process):
  def setup(known_nodes, scheduler):
    self.custom_config = configparser.ConfigParser()
    self.custom_config.read('config.ini')
    # for initial node, known_nodes is
    # all the other initial nodes; otherwise it is empty set

    # **** variables for managing churn ****

    
    # known nodes for initial set of nodes present hence it's is joined becomes true and for new created node
    #it's an empty side . Thus it's is joined is false.
    self.is_joined = bool(known_nodes) # whether node has joined the system

    self.join_bound = 0 # number of enter-echo msgs to receive
                        # before joining
    self.join_counter = 0 # number of enter-echo messages received
    # Initially assume every know node has entered and joined
    self.Changes = (setof(('enter',q), q in known_nodes) | 
                    setof(('join',q), q in known_nodes))  # set of ENTER, 
                                   #LEAVE, and JOINED events known to node 
    if (known_nodes):  # self is one of the initial nodes
        Changes.add(('enter',self))
        Changes.add(('join',self))

    # *** variables for managing churn and reading/writing simulated register
    self.val = None # latest register value known to node
    self.num = 0 # sequence number of latest value known to node
    self.w_id = None  # id of node that wrote latest value known to node

    # **** variables for reading/writing simulated register ****
    self.temp = 0 # temporary storage for value being read or written
    self.tag = 0  # uniquely identify read and write phases of an operation
    self.rw_bound = 0 # number of replies/acks needed to finish a phase
    self.rw_counter = 0  # number of replies/acks received for phase
    self.rp_pending = False # whether a read phase is in progress
    self.wp_pending = False # whether a write phase is in progress
    self.read_pending = False #  whether a read operation is in progress
    self.write_pending = False # whether a write operation is in progress

    # code for node entering the system AFTER initial time, in response
    # to receiving enter-signal message from scheduler
    if known_nodes == set():
        Changes.add(('enter',self))
        bcast('enter', self)
        output('entered, bcasted enter msgs')

  # ********** end of Node setup method 

  # broadcast is actually peformed by scheduler which has perfect global
  # knowledge of which nodes are present in the system
  
  
  def delayed_send(m, rec):
    # We can have a max of 
    delay = random.randint(0, float(custom_config["GENERAL"]["max_delay"])*100)/100 
    if await(False):pass
    elif timeout(delay): pass
    send(m, to=rec)
  
  def bcast(*m):
      delayed_send(('bcast',m), scheduler)

  # ***************** methods for managing the churn ******************

  # set of nodes that p believes are currently present (entered but not left) 
  def Present():
      return setof(q, ('enter',q) in Changes, ('leave',q) not in Changes)

  def receive(msg = ('enter',p)):
      #output('Received enter from',p)
      Changes.add(('enter',p))
      bcast('enter-echo', Changes, (val, num, w_id), is_joined, p)

  def receive(msg = ('enter-echo', C, (v, s, i), j, p)):
      #output('received enter-echo, checking,sequence number and id for process entering with process id',p)
      # Why does this need the ID
      i 
      Changes = Changes | C
      if (not is_joined) and (p == self):
          if (j == True) and (join_bound == 0):     #since we are counting join_bound on basis of info from an already joined node
              join_bound = GAMMA * len(Present())
              output('join_bound set to', join_bound, 'based on Present size of', len(Present()))
          join_counter += 1
          if (join_counter >= join_bound) and (join_bound > 0):
          	#we do need join_bound >0 condition because the first few enter-echo messages can be from process not joined in
          	#the system and in this case the join_counter will exceed join_bound which was never set
              is_joined = True
              output('joined')
              Changes.add(('join',self))
              delayed_send(('joined'), scheduler) # tell scheduler I've joined
              output('sent joined to scheduler')
              bcast('joined',self)

  def receive(msg = ('joined', p)):
      #output('received joined message from process id',p)
      Changes.add(('join',p))
      Changes.add(('enter',p))
      bcast('joined-echo',p)

  def receive(msg = ('joined-echo',p)):
      #output('recieved joined echo about process with id',p)
      Changes.add(('join',p))
      Changes.add(('enter',p))

  # node leaves in response to 'leave-signal' msg from scheduler
  def receive(msg = ('leave-signal')): 
      output('received leave signal, exiting')
      bcast('leave', self)
      output('exiting')
      exit()

  def receive(msg = ('leave',p)):
      # output('received leave about process with id',p)
      Changes.add(('leave',p))
      bcast('leave-echo',p)

  def receive(msg = ('leave-echo',p)):
      #output('received leave-echo about process with id',p)
      Changes.add(('leave',p))

  # ***************** methods for simulating reads and writes **************

  # set of nodes that p believes are currently members (joined but not left) 
  def Members():
    return setof(q, ('join',q) in Changes, ('leave',q) not in Changes)

  def receive(msg='read'):
      output('read invoked')
      # Needed to measure the timestamp of the read request
      send(('readstarttime', num, w_id), to=scheduler)
      read_pending = True
      begin_read_phase()

  def receive(msg = ('write', v)):
      output('write invoked, value:', v)
      write_pending = True
      temp = v
      begin_read_phase()

  def begin_read_phase():
      output('begin read phase')
      tag += 1
      bcast('query', tag, self)
      rw_bound = BETA * len(Members())
      output('rw_bound set to', rw_bound, 'based on Members size of', len(Members()))
      rw_counter = 0
      rp_pending = True

  def receive(msg = ('reply', (v, s, i), rt, p)):
#     output('====reply', rt)
      if rp_pending and (rt == tag) and (p==self):
          if (s, i) > (num, w_id):
              val, num, w_id = v, s, i
          rw_counter += 1
          if (rw_counter >= rw_bound):
              rp_pending = False
              begin_write_phase()

  def begin_write_phase():
      output('begin write phase')
      if write_pending:
          val = temp
          num += 1
          w_id = self
      if read_pending:
          temp = val
      bcast('update', (temp, num, w_id), tag, self)
      if write_pending:
        # Required to calculate the total ordering
        send(('writeupdatetime', num, w_id, temp), to=scheduler)
      else:
        send(('readendtime', num, w_id, temp), to=scheduler)
      output('updated values are being sent as value,sequence,w_id',temp,num,w_id)
      rw_counter = 0
      wp_pending = True

  def receive(msg = ('ack',wt,p)):
      if wp_pending and (wt == tag) and (p == self):
          rw_counter += 1
          if (rw_counter >= rw_bound):
              wp_pending = False
              if (read_pending):
                  read_pending = False
                  delayed_send(('return',temp), scheduler)     #make scheduler note the time here
              if (write_pending):
                  write_pending = False
                  delayed_send('ack', scheduler)               #make scheduler note the time here

  # ***** "server" code follows ****

  def receive(msg= ('update', (v, s, i), wt, q)):
    #output('REcieved an update message')
    if w_id == None or (s, i) > (num, w_id):
       val, num, w_id = v, s, i
    if is_joined:
       bcast('ack', wt, q)
    bcast('update-echo', (val, num, w_id))

  def receive(msg = ('query', rt, p)):
#    print('====qeury', p, is_joined)
    if is_joined:
#      print('====qeury', p)
      bcast('reply', (val, num, w_id), rt, p)
      #output('sent a reply message for query message with val ,num and w id as ',val, num, w_id)

  def receive(msg = ('update-echo', (v, s, i))):
    #output('recived an update echo message')
    if (s, i) > (num, w_id):
        val, num, w_id = v, s, i
#to include some random unavailibility if nodes
  def receive(msg ='sleep'):
    output('sleeping for 1 second')
    time.sleep(int(custom_config['PERFORMANCE']['sleep_time_node']))
  	
  def receive(msg= 'done'):
    #output('exiting by done')
    exit()

# ********** run *******************************

  def run():
#    output(self, 'running')
    await(False) # Wait till the condition is true
    output('node', self, 'at end of run')

# ----------------------------------------
# Scheduler class
# ----------------------------------------

class Scheduler (process):
  def setup():
      self.custom_config = configparser.ConfigParser()
      self.custom_config.read('config.ini') 
      self.nodes = new(Node, num=NUM_INIT_NODE)
      #### Variable declarations
      self.allnodes = nodes
      self.joined = nodes
      self.entered = nodes
      # A map with process_id -> time_taken_from_enter_to_join
      self.join_times = {}
      # A map with process_id -> [time_taken_to_write]
      self.write_times = {} 
      # A map with process_id -> [time_taken_to_read]
      self.read_times={}
      # to keep a track of crashed nodes 
      self.crash_nodes=set()
      # to keep a track of left nodes 
      self.left_nodes=set()
      # A process is considered in-use of a request has been issued to it
      # for either a read or a write
      self.in_use = set()
      # read write timestamps to check the order
      self.readwriteorder = []
      # enter leave times to check intervals of time
      self.enterleaveorder = []
      # max allowed delay for one message
      self.max_delay = float(self.custom_config["GENERAL"]["max_delay"])
      # delay adjustment to account for cpu time
      self.delay_adjustment = float(self.custom_config["GENERAL"]["delay_adjustment"])
      #### END Variable declarations
      self.join_delay = (max_delay * 4)  + delay_adjustment
      
      for p in nodes: setup(p, [nodes-{p}, self])
      start(nodes)
      output('nodes present initially are', nodes)
      
  def print_stats():
    for pid in join_times:
      if pid in joined:
        output("Process ", pid, " took ", join_times[pid], " seconds to join")
      else:
        output("Process ", pid, "never joined the system")
    print(write_times)
    print(read_times)

  def crash_node(p):
  	crash_nodes.add(p)

  def test_general_correctness():
    # Just a bunch random tests. Here we go completely crazy and 
    # make things crazy
    rounds= int(custom_config['GENERAL']['num_of_rounds'])
    while(rounds>0):
        output('ROUND NUMBER',rounds)
        p = random.choice(list(joined-crash_nodes))
        output('randomly chosen node is', p)

        test_leave(p)
        test_enter()
        # test_enter()
        # test_enter()
        # test_enter()
        # test_enter()
        # test_enter()
        # test_enter()

        p= random.choice(list(nodes))
        r=random.randint(1,10)              #crash with a random probability
        if (r>1):
      	    crash_node(p)
      	    output('Randomly chosen node to crash ',p)

        r=random.randint(1,10)
        if (r>0):
          p=random.choice(list(nodes-crash_nodes))
          output('Sending sleep to ',p)
          send('sleep',to=p)
        p= random.choice(list(nodes))
        r=random.randint(1,10)              #crash with a random probability
        if (r>1):
          crash_node(p)
          output('Randomly chosen node to crash ',p)      
        # Bits to identify whether we randomly do a read of a write 
        # If we have a True as the o/p of random choice then we do a read
        READ = True
        WRITE = False
        for x in range(int(custom_config["GENERAL"]["num_read_writes"])):
          read_or_write = random.choice([True, False])
          allowed_nodes = list(nodes-crash_nodes-in_use)
          if allowed_nodes:
            p = random.choice(allowed_nodes)
            output('randomly chosen node is: ', p)
            in_use.add(p)
            if read_or_write == READ:
              test_read(p)
              output("Issuing a read command")
            else:
              val = random.randint(1,100)
              output("Issuing a write command with value: ", val)
              test_write(p, val)
          else:
            output("No nodes present to perform read or write operation")
            output("Skipping one round...")
            rounds-=1
            break
        rounds-=1 
   

  def test_condition_1():
    # Checking if the noumber th enodeoes of the node
    rounds= int(custom_config['GENERAL']['num_of_rounds'])
    while(rounds>0):
        output('ROUND NUMBER',rounds)
        p = random.choice(list(joined-crash_nodes))
        output('randomly chosen node is', p)

        test_leave(p)
        test_enter()
        # test_enter()
        # test_enter()
        # test_enter()
        # test_enter()
        # test_enter()
        # test_enter()

        p= random.choice(list(nodes))
        r=random.randint(1,10)              #crash with a random probability
        if (r>1):
            crash_node(p)
            output('Randomly chosen node to crash ',p)

        r=random.randint(1,10)
        if (r>0):
          p=random.choice(list(nodes-crash_nodes))
          output('Sending sleep to ',p)
          send('sleep',to=p)
        p= random.choice(list(nodes))
        r=random.randint(1,10)              #crash with a random probability
        if (r>1):
          crash_node(p)
          output('Randomly chosen node to crash ',p)      
        # Bits to identify whether we randomly do a read of a write 
        # If we have a True as the o/p of random choice then we do a read
        READ = True
        WRITE = False
        for x in range(int(custom_config["GENERAL"]["num_read_writes"])):
          read_or_write = random.choice([True, False])
          allowed_nodes = list(nodes-crash_nodes-in_use)
          if allowed_nodes:
            p = random.choice(allowed_nodes)
            output('randomly chosen node is: ', p)
            in_use.add(p)
            if read_or_write == READ:
              test_read(p)
              output("Issuing a read command")
            else:
              val = random.randint(1,100)
              output("Issuing a write command with value: ", val)
              test_write(p, val)
          else:
            output("No nodes present to perform read or write operation")
            output("Skipping one round...")
            rounds-=1
            break
        rounds-=1 


  def test_condition_3():
    # The read and write operations are atomic:
    #there is an ordering of all completed reads and writes
    #and some subset of the uncompleted writes such that
    #every read returns the value of the latest preceding
    #write (or the initial value of the register if there is no
    #preceding write) and, if an operation op1 finishes before
    #another operation op2 begins, then op1 occurs before
    #op2 in the ordering.
    
    # The idea is the we keep testing our read and writes. A number of random reads and random writes.
    # Once we have that test to ensure that if a preceding write is complete, a read returns the correct values
    
    # Bits to identify whether we randomly do a read of a write 
        # If we have a True as the o/p of random choice then we do a read
    READ = True
    WRITE = False
    
    # To simplify our testing we assuming that a value can be used exactly once and similarly
    # every process is used once.
    for x in range(int(custom_config["GENERAL"]["num_read_writes"])):
      read_or_write = random.choice([True, False])
      p = random.choice(list(nodes-in_use))
      output('randomly chosen node is: ', p)
      in_use.add(p)
      in_use.add(p)
      if read_or_write == READ:
        test_read(p)
        output("Issuing a read command")
      else:
        # Keep looping till we see a new value
        val = random.randint(1,1000)
        output("Issuing a write command with value: ", val)
        test_write(p, val)
      # Introduce a small delay between two sends
      if await(False):pass
      elif timeout(0.1): output("Waited for 0.1 seconds")
     
    output("Waiting 5 seconds for all responses to arrive before checking")    
    # Introduce a small delay between two sends
    if await(False):pass
    elif timeout(10): output("Waited for 10 seconds")

    check_condition_3_validity()
    
  def anyof(s):
        return next(iter(s)) if s else None

  def check_condition_3_validity():
    # Now that we have made out read and writes, we check the schedulers 
    # received queue to check whether the data returned is ordered correctly.
    
    
    output("Read write order is: ", readwriteorder)    
    def getPreviousWrite(readwrites):
        # Search for the first write from the end
        for item in reversed(readwrites):
            if item[0] == "write":
                return item  
    def getFirstValReturnedByProcess(readwrites, pid):
        # Get the value of return for the corresponding read start.

        for item in readwrites:
            if item[0] == "readend" and item[3] == pid:
                return item[4]
        return None

    # For every read, find the previous write. Then check whether the values match. If they don't 
    # we have a problem.
    # We check from the second element in the list because we don't care about the first read.
    for i in range(1, len(readwriteorder)):
        item = readwriteorder[i]
        # We have a read, find the previous write or ensure that there is no write if the value is None
        if item[0] == 'readstarttime':
            p = item[3]
            # Get the value the read returned
            val = getFirstValReturnedByProcess(readwriteorder[i:], p)
            previouswrite = getPreviousWrite(readwriteorder[:i])
            if previouswrite == None:
                if val != None:
                    output("ERRORa!")
            else:
                if val == None:
                    output("ERRORb!")
                elif val != previouswrite[4]:
                    output("ERRORc!")
    
  def run():
    
    #test_general_correctness()
    test_condition_3()    
    output('Exited the loop')
    await(received('done'))
    print_stats()
    output('scheduler terminating')
    
  def get_count_before(ts):
    valid_events =  [x for x in enterleaveorder if x[0] < ts]
    if valid_events:
        # Get the count from the lastest event
        return valid_events[-1][1]
    else:
        return NUM_INIT_NODE

  def get_event_count_in(start, end):
      ret=[x for x in enterleaveorder if x[0]<end and x[0] > start]
      return len(ret)

  def churn_allowed():
      # Check the number of enter and leaves in current time - D
      # If this is greater than alpha*N(t-D) don't allow churn
      curtime = time.time()
      prevtime = curtime - max_delay
      nt = get_count_before(prevtime)
      if nt*ALPHA < (get_event_count_in(prevtime, curtime)+1):
        return False
      else:
        return True
    
  def test_leave(p):
      if not churn_allowed():
        output('NODE CANNOT LEAVE THE SYSTEM')
        return
      enterleaveorder.append([time.time(), len(nodes)])
      send('leave-signal', to= p)
      output('making {0} node leave'.format(p))
      left_nodes.add(p)
      nodes.remove(p)

  def test_enter():
      if not churn_allowed():
        output("NEW NODE CANNOT ENTER THE SYSTEM")
        return
      enterleaveorder.append([time.time(), len(nodes)])
      p = new(Node, [set(), self])
      start(p)
      nodes.add(p)
      
  def receive(msg='joined', from_=p):
      join_times[p] = time.time() - join_times[p]
      if join_times[p] > join_delay:
        output('\n###Process {0} Join time: {1} exceeds maximum allowed delay {2}\n'.format(p, join_times[p], join_delay))
      output('join operation completed for ', p)

  def test_read(p):
      send('read', to= p)
      if p in read_times:
        read_times[p].append(time.time())
      else:
        read_times[p] = [time.time()]
      
  def receive(msg=('return',temp), from_=p):
      output('read returns with value ', temp)
      read_times[p][-1] = time.time() - read_times[p][-1]
      # p is no longer in use, so remove it from the in_use set
      in_use.remove(p)
      

  def test_write(p,val):
      output('test write start')
      send(('write',val), to= p)
      if p in write_times:
        write_times[p].append(time.time())
      else:
        write_times[p] = [time.time()]

      
  def receive(msg=('ack'), from_=p):
      output('write returned an ack from: ', p)
      write_times[p][-1] = time.time() - write_times[p][-1]
      # p is no longer in use, so remove it from the in_use set
      in_use.remove(p)

  def receive(msg = ('bcast',m), from_=pid):
      if m[0] == "enter":
        join_times[pid] = time.time()
      send(m, to=nodes-crash_nodes)

       
  def receive(msg= ('writeupdatetime', num, wid, val), from_=pid):
    readwriteorder.append([num, wid,'write', pid, val])
    
  def receive(msg=('readstarttime', num, wid), from_=pid):
    readwriteorder.append([num, wid,'read', pid])
    
  def receive(msg=('readendtime', num, wid, val), from_=pid):
    readwriteorder.append([num, wid, 'readend', pid, val])

  def receive(msg = 'done'):
      output('done received by scheduler')
      output('total nodes in the system',nodes)
      send('done', to= nodes)
      output('scheduler sent done msgs to nodes', nodes)


# ----------------------------------------
# main
# ----------------------------------------



def main():
  config(clock = Lamport)
  scheduler = new(Scheduler,[])
  start(scheduler)
  time.sleep(15)
  # instead of hard timelimit can we use other parameters to stop the system?
  send('done', to= scheduler)
  output('sent done to schedule')

  