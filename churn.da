import random
import time
import configparser

BETA = 0.6
GAMMA = 0.6
NUM_INIT_NODE = 6


# ----------------------------------------
# Node class
# ----------------------------------------

"""
DOES THIS WORK WITH N=1?
If there's no ID in the enter-echo message, they can be spoofed

- Make each node spontaneously read/write values into the register. This ||ism will break the code
- Randomize based on a frequency and time that can be adjusted. 


- For two consecutive writes  (in a short time span) it considers on the second because the tag is overwritten. This could be a problem
- Node randomly crashes


- Possible problems with the algo
------ I think a simultaneous read and write could fail. If the read's RP finishes, after that the RP&WR of the write occurs. Now the read has an out-dated value of the register.

"""


class Node (process):
  def setup(known_nodes, scheduler):
    self.custom_config = configparser.ConfigParser()
    self.custom_config.read('config.ini')
    # for initial node, known_nodes is
    # all the other initial nodes; otherwise it is empty set

    # **** variables for managing churn ****

    
    # known nodes for initial set of nodes present hence it's is joined becomes true and for new created node
    #it's an empty side . Thus it's is joined is false.
    self.is_joined = bool(known_nodes) # whether node has joined the system

    self.join_bound = 0 # number of enter-echo msgs to receive
                        # before joining
    self.join_counter = 0 # number of enter-echo messages received
    # Initially assume every know node has entered and joined
    self.Changes = (setof(('enter',q), q in known_nodes) | 
                    setof(('join',q), q in known_nodes))  # set of ENTER, 
                                   #LEAVE, and JOINED events known to node 
    if (known_nodes):  # self is one of the initial nodes
        Changes.add(('enter',self))
        Changes.add(('join',self))

    # *** variables for managing churn and reading/writing simulated register
    self.val = None # latest register value known to node
    self.num = 0 # sequence number of latest value known to node
    self.w_id = None  # id of node that wrote latest value known to node

    # **** variables for reading/writing simulated register ****
    self.temp = 0 # temporary storage for value being read or written
    self.tag = 0  # uniquely identify read and write phases of an operation
    self.rw_bound = 0 # number of replies/acks needed to finish a phase
    self.rw_counter = 0  # number of replies/acks received for phase
    self.rp_pending = False # whether a read phase is in progress
    self.wp_pending = False # whether a write phase is in progress
    self.read_pending = False #  whether a read operation is in progress
    self.write_pending = False # whether a write operation is in progress

    # code for node entering the system AFTER initial time, in response
    # to receiving enter-signal message from scheduler
    if known_nodes == set():
        Changes.add(('enter',self))
        bcast('enter', self)
        output('entered, bcasted enter msgs')

  # ********** end of Node setup method 

  # broadcast is actually peformed by scheduler which has perfect global
  # knowledge of which nodes are present in the system
  
  
  def delayed_send(m, rec):
    # We can have a max of 
    delay = random.randint(0, float(custom_config["GENERAL"]["max_delay"])*100)/100 
    if await(False):pass
    elif timeout(delay): pass
    send(m, to=rec)
  
  def bcast(*m):
      delayed_send(('bcast',m), scheduler)

  # ***************** methods for managing the churn ******************

  # set of nodes that p believes are currently present (entered but not left) 
  def Present():
      return setof(q, ('enter',q) in Changes, ('leave',q) not in Changes)

  def receive(msg = ('enter',p)):
      output('Received enter from',p)
      Changes.add(('enter',p))
      bcast('enter-echo', Changes, (val, num, w_id), is_joined, p)

  def receive(msg = ('enter-echo', C, (v, s, i), j, p)):
      output('received enter-echo, checking,sequence number and id for process entering with process id',p)
      # Why does this need the ID
      if (s, i) > (num, w_id, id):
          val, num, w_id = v, s, i
      Changes = Changes | C
      if (not is_joined) and (p == self):
          if (j == True) and (join_bound == 0):     #since we are counting join_bound on basis of imfo from an already joined node
              join_bound = GAMMA * len(Present())
              output('join_bound set to', join_bound, 'based on Present size of', len(Present()))
          join_counter += 1
          if (join_counter >= join_bound) and (join_bound > 0):
          	#we do need join_bound >0 condition because the first few enter-echo messages can be from process not joined in
          	#the system and in this case the join_counter will exceed join_bound which was never set
              is_joined = True
              output('joined')
              Changes.add(('join',self))
              delayed_send(('joined'), scheduler) # tell scheduler I've joined
              output('sent joined to scheduler')
              bcast('joined',self)

  def receive(msg = ('joined', p)):
      output('received joined message from procedd id',p)
      Changes.add(('join',p))
      Changes.add(('enter',p))
      output('sending broadcast about process joined with id',p)
      bcast('joined-echo',p)

  def receive(msg = ('joined-echo',p)):
      #output('recieved joined echo about process with id',p)
      Changes.add(('join',p))
      Changes.add(('enter',p))

  # node leaves in response to 'leave-signal' msg from scheduler
  def receive(msg = ('leave-signal')): 
      output('received leave signal, exiting')
      bcast('leave', self)
      output('exiting')
      exit()

  def receive(msg = ('leave',p)):
      output('received leave about process with id',p)
      Changes.add(('leave',p))
      bcast('leave-echo',p)

  def receive(msg = ('leave-echo',p)):
      output('received leave-echo about process with id',p)
      Changes.add(('leave',p))

  # ***************** methods for simulating reads and writes **************

  # set of nodes that p believes are currently members (joined but not left) 
  def Members():
    return setof(q, ('join',q) in Changes, ('leave',q) not in Changes)

  def receive(msg='read'):
      output('read invoked')
      read_pending = True
      begin_read_phase()

  def receive(msg = ('write', v)):
      output('write invoked, value:', v)
      write_pending = True
      temp = v
      begin_read_phase()

  def begin_read_phase():
      output('begin read phase')
      tag += 1
      bcast('query', tag, self)
      rw_bound = BETA * len(Members())
      output('rw_bound set to', rw_bound, 'based on Members size of', len(Members()))
      rw_counter = 0
      rp_pending = True

  def receive(msg = ('reply', (v, s, i), rt, p)):
#     output('====reply', rt)
      if rp_pending and (rt == tag) and (p==self):
          if (s, i) > (num, w_id):
              val, num, w_id = v, s, i
          rw_counter += 1
          if (rw_counter >= rw_bound):
              rp_pending = False
              begin_write_phase()

  def begin_write_phase():
      output('begin write phase')
      if write_pending:
          val = temp
          num += 1
          w_id = self
      if read_pending:
          temp = val
      bcast('update', (temp, num, w_id), tag, self)
      output('updated vlaues are being sent as value,sequence,w_id',temp,num,w_id)
      rw_counter = 0
      wp_pending = True

  def receive(msg = ('ack',wt,p)):
      if wp_pending and (wt == tag) and (p == self):
          rw_counter += 1
          if (rw_counter >= rw_bound):
              wp_pending = False
              if (read_pending):
                  read_pending = False
                  delayed_send(('return',temp), scheduler)
              if (write_pending):
                  write_pending = False
                  delayed_send('ack', scheduler)

  # ***** "server" code follows ****

  def receive(msg= ('update', (v, s, i), wt, q)):
    #output('REcieved an update message')
    if w_id == None or (s, i) > (num, w_id):
       val, num, w_id = v, s, i
    if is_joined:
       bcast('ack', wt, q)
    bcast('update-echo', (val, num, w_id))

  def receive(msg = ('query', rt, p)):
#    print('====qeury', p, is_joined)
    if is_joined:
#      print('====qeury', p)
      bcast('reply', (val, num, w_id), rt, p)
      output('sent a reply message for query message with val ,num and w id as ',val, num, w_id)

  def receive(msg = ('update-echo', (v, s, i))):
    #output('recived an update echo message')
    if (s, i) > (num, w_id):
        val, num, w_id = v, s, i
#to include some random unavailibility if nodes
  def receive(msg ='sleep'):
    output('sleeping for 1 second')
    time.sleep(int(custom_config['PERFORMANCE']['sleep_time_node']))
  	
  def receive(msg= 'done'):
    output('exiting by done')
    exit()

# ********** run *******************************

  def run():
#    output(self, 'running')
    await(False) # Wait till the condition is true
    output('node', self, 'at end of run')

# ----------------------------------------
# Scheduler class
# ----------------------------------------

class Scheduler (process):
  def setup():
      self.custom_config = configparser.ConfigParser()
      self.custom_config.read('config.ini') 

      self.custom_config = configparser.ConfigParser()
      self.custom_config.read('config.ini')
      self.nodes = new(Node, num=NUM_INIT_NODE)
      #### Variable declarations
      self.allnodes = nodes
      self.joined = nodes
      self.entered = nodes
      # A map with process_id -> time_taken_from_enter_to_join
      self.join_times = {}
      # A map with process_id -> [time_taken_to_write]
      self.write_times = {} 
      # A map with process_id -> [time_taken_to_read]
      self.read_times={}
      # to keep a track of crashed nodes 
      self.crash_nodes=set()
      # A process is considered in-use of a request has been issued to it
      # for either a read or a write
      self.in_use = set()
      #### END Variable declarations

      self.replies = set()
      
      for p in nodes: setup(p, [nodes-{p}, self])
      start(nodes)
      output('nodes present initially are', nodes)
      
  def print_stats():
    for pid in join_times:
      output("Process ", pid, " took ", join_times[pid], " seconds to join")
    print(write_times)
    print(read_times)

  def crash_node(p):
  	crash_nodes.add(p)

   
  def run():
    
    rounds= int(custom_config['GENERAL']['num_of_rounds'])
    while(rounds>0):
        output('ROUND NUMBER',rounds)
        p = random.choice(list(nodes-crash_nodes))
        output('randomly chosen node is', p)


        test_leave(p)
        test_enter()
       # test_enter()
       # test_enter()

        p= random.choice(list(nodes))
        r=random.randint(1,10)              #crash with a random probability
        if (r>1):
      	    crash_node(p)
      	    output('Randomly chosen node to crash ',p)

        r=random.randint(1,10)
        if (r>0):
          p=random.choice(list(nodes-crash_nodes))
          output('Sending sleep to ',p)
          send('sleep',to=p)
        p= random.choice(list(nodes))
        r=random.randint(1,10)              #crash with a random probability
        if (r>1):
          crash_node(p)
          output('Randomly chosen node to crash ',p)      
        # Bits to identify whether we randomly do a read of a write 
        # If we have a True as the o/p of random choice then we do a read
        READ = True
        WRITE = False
        for x in range(int(custom_config["GENERAL"]["num_read_writes"])):
          read_or_write = random.choice([True, False])
          p = random.choice(list(nodes-crash_nodes-in_use))
          output('randomly chosen node is: ', p)
          in_use.add(p)
          if read_or_write == READ:
            test_read(p)
            output("Issuing a read command")
          else:
            val = random.randint(1,100)
            output("Issuing a write command with value: ", val)
            test_write(p, val)
        rounds-=1
        
    output('Exited the loop')
    await(received('done'))
    print_stats()
    output('scheduler terminating')

  def test_leave(p):
      send('leave-signal', to= p)
      nodes.remove(p)

  def test_enter():
      p = new(Node, [set(), self])
      start(p)
      nodes.add(p)
      await(some(received('joined', from_=_p, clk=c),
                 has= ('joined',p,c) not in replies))     #maybe has is present becuase some needs has 
      output('join completed indication received', p, c)
      # We already have the enter times, now they have joined. So we know how long it
      # took to enter
      join_times[p] = time.time() - join_times[p]
      replies.add(('joined',p,c))
      output('the replies set is as follows',replies)

  def test_read(p):
      send('read', to= p)
      if p in read_times:
        read_times[p].append(time.time())
      else:
        read_times[p] = [time.time()]
      
  def receive(msg=('return',temp), from_=p):
      output('read returns with value ', temp)
      read_times[p][-1] = time.time() - read_times[p][-1]
      # p is no longer in use, so remove it from the in_use set
      in_use.remove(p)
      

  def test_write(p,val):
      output('test write start')
      send(('write',val), to= p)
      if p in write_times:
        write_times[p].append(time.time())
      else:
        write_times[p] = [time.time()]

      
  def receive(msg=('ack'), from_=p):
      output('write returned an ack from: ', p)
      write_times[p][-1] = time.time() - write_times[p][-1]
      # p is no longer in use, so remove it from the in_use set
      in_use.remove(p)

  def receive(msg = ('bcast',m), from_=pid):
      if m[0] == "enter":
        join_times[pid] = time.time()
        
      send(m, to=nodes-crash_nodes)

  def receive(msg = 'done'):
      output('done received by scheduler')
      output('total nodes in the system',nodes)
      send('done', to= nodes)
      output('scheduler sent done msgs to nodes', nodes)

# ----------------------------------------
# main
# ----------------------------------------



def main():
  config(clock = Lamport)
  scheduler = new(Scheduler, [])
  start(scheduler)
  time.sleep(15)
  send('done', to= scheduler)
  output('sent done to schedule')

  